import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated
 * parser class. */
parser code {:

    /* The following fields and methods deal with error reporting
     * Avoid changing these unless you know what you are doing. */

    /** Node that accumulates error messages to be added to the Program
     *  node produced as a result. */
    public final Errors errors = new Errors(new ArrayList<>());

    /** Return the Program node that results from parsing the stream of
     *  tokens produced by lexical analysis.  In the case of syntax errors,
     *  the program may be empty, but will have error messages. */
    public Program parseProgram(boolean debug) {
        try {
            Symbol result = debug ? debug_parse() : parse();
            if (result == null || !(result.value instanceof Program)) {
                return new Program(new Location(0, 0), new Location(0, 0),
                                   new ArrayList<Declaration>(),
                                   new ArrayList<Stmt>(),
                                   errors);
            } else {
                return (Program) result.value;
            }
        } catch (RuntimeException excp) {
            throw excp;
        } catch (Exception excp) {
            String msg =
                String.format("Internal parser error detected: %s%n", excp);
            throw new AssertionError(msg);
        }
    }

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                String text = ((ChocoPyLexer) getScanner()).yytext();
                errors.syntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    "Parse error near token %s: %s", token, text);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        /* Do not die */
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE              
 *
 * The rules provided below parse expressions of the form <INT> + <INT> + ... 
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * location of the left end of the leftmost symbol in a rule and the
 * location of the right end of the rightmost symbol. The auto-generated
 * variables have names `<sym>xleft` and `<sym>xright`, where <sym> is the
 * name given to the symbol using the colon notation.
 *
 * When you have nonterminals that are lists of things, e.g. List<Stmt> or
 * List<Declaration>, it is helpful to get the leftmost and rightmost
 * source location from within this list; we have provided some utility
 * functions below to do just that.
 **************************************************************************/


/* The following code section is copied verbatim to the class that performs
 * production-rule actions. */
action code {:

    /** Return a mutable list initially containing the single value ITEM. */
    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** If ITEM is non-null, appends it to the end of LIST.  Then returns
     *  LIST. */
    <T> List<T> combine(List<T> list, T item) {
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** Return a mutable empty list. */
    <T> List<T> empty() {
        return new ArrayList<T>();
    }

    /** Return the leftmost non-whitespace location in NODES, or null if NODES
     *  is empty.  Assumes that the nodes of NODES are ordered in increasing
     *  order of location, from left to right. */
    ComplexSymbolFactory.Location getLeft(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node first = nodes.get(0);
        return new ComplexSymbolFactory.Location(first.getLocation()[0],
                                                 first.getLocation()[1]);
    }

:}

/* Terminal symbols (tokens returned by the lexer).  The declaration
 *     terminal <identifier1>, <identifier2>, ...;
 * declares each <identifieri> as the denotation of a distinct type terminal
 * symbol for use in the grammar.  The declaration
 *     terminal <type> <identifier1>, ...;
 * does the same, and in addition indicates that the lexer supplies a
 * semantic value of type <type> for these symbols that may be referenced
 * in actions ( {: ... :} ).
 */

terminal DEF, CLASS, IF, ELSE, ELIF, WHILE, FOR, IN, RETURN, PASS, NOT, AND, OR, IS, GLOBAL, NONLOCAL;
terminal TRUE, FALSE, NONE;
terminal EQ, EQEQ, NOTEQ, LT, LTE, GT, GTE;
terminal PLUS, MINUS, MULT, INTDIV, MOD;
terminal DOT, COLON, COMMA, LPAREN, RPAREN, LBRACK, RBRACK, ARROW, INDENT, DEDENT;
terminal NEWLINE, UNRECOGNIZED;

terminal Integer NUMBER;
terminal String STRING_LITERAL;
terminal String IDENTIFIER;

/* Returned by the lexer for erroneous tokens.  Since it does not appear in
 * the grammar, it indicates a syntax error. */
  

/* Nonterminal symbols (defined in production rules below).
 * As for terminal symbols, 
 *     non terminal <type> <identifier1>, ..., <identifiern>; 
 * defines the listed nonterminal identifier symbols to have semantic values
 * of type <type>. */

non terminal Program           program;
non terminal List<Declaration> declaration_list;
non terminal Declaration       declaration, var_def, func_def, class_def;
non terminal List<Stmt>        stmt_list, opt_stmt_list, block;
non terminal Stmt              stmt, expr_stmt, return_stmt, pass_stmt, while_stmt, for_stmt, global_stmt, nonlocal_stmt;
non terminal Expr              expr, binary_expr, unary_expr, literal_expr, primary_expr;
non terminal Expr              func_call, attr_access, index_access;
non terminal List<Expr>        expr_list, opt_expr_list;
non terminal List<TypedVar>    opt_typed_args, typed_arg_list;
non terminal List<ElifBranch>  opt_elif_else, elif_list;
non terminal TypeAnnotation    type;
non terminal Object            if_stmt;
/* Precedences (lowest to highest) for resolving what would otherwise be
 * ambiguities in the form of shift/reduce conflicts.. */

precedence left OR;
precedence left AND;
precedence right NOT;
precedence nonassoc EQEQ, NOTEQ, LT, LTE, GT, GTE, IS;
precedence left PLUS, MINUS;
precedence left MULT, INTDIV, MOD;
precedence left DOT, LBRACK, LPAREN;


/* The start symbol. */
start with program;


/*****  GRAMMAR RULES *****/

program ::= declaration_list:d opt_stmt_list:s
        {: RESULT = new Program(d.isEmpty() ? getLeft(s) : getLeft(d),
                                sxright, d, s, errors); :}
        ;

declaration_list ::= declaration:d {: RESULT = single(d); :}
                   | declaration_list:l declaration:d {: RESULT = combine(l, d); :}
                   ;

declaration ::= var_def:d {: RESULT = d; :}
             | func_def:f {: RESULT = f; :}
             | class_def:c {: RESULT = c; :}
             ;

var_def ::= IDENTIFIER:id COLON type:t EQ expr:e NEWLINE:nl
           {: RESULT = new VarDef(idxleft, nlxright, id, t, e); :}
         ;

func_def ::= DEF IDENTIFIER:id LPAREN opt_typed_args:args RPAREN ARROW type:ret_type COLON NEWLINE block:b
            {: RESULT = new FuncDef(idxleft, getRight(b), id, args, ret_type, b); :}
          ;

class_def ::= CLASS IDENTIFIER:id LPAREN IDENTIFIER:parent RPAREN COLON NEWLINE block:body
            {: RESULT = new ClassDef(idxleft, getRight(body), id, parent, body); :}
           ;

opt_typed_args ::= /* empty */ {: RESULT = empty(); :}
                | typed_arg_list:l {: RESULT = l; :}
                ;

typed_arg_list ::= IDENTIFIER:id COLON type:t {: RESULT = single(new TypedVar(idxleft, t)); :}
                 | typed_arg_list:l COMMA IDENTIFIER:id COLON type:t
                   {: RESULT = combine(l, new TypedVar(idxleft, t)); :}
                 ;

stmt_list ::= stmt:s              {: RESULT = single(s); :}
           | stmt_list:l stmt:s   {: RESULT = combine(l, s); :}
           | stmt_list:l error    {: RESULT = l; :}
           ;

opt_stmt_list ::= /* empty */ {: RESULT = empty(); :}
               | stmt_list:s {: RESULT = s; :}
               ;

block ::= INDENT stmt_list:s DEDENT {: RESULT = s; :}
       ;

stmt ::= expr_stmt
      | global_stmt
      | nonlocal_stmt
      | return_stmt
      | pass_stmt
      | if_stmt
      | while_stmt
      | for_stmt
      | UNRECOGNIZED:u NEWLINE:nl {: RESULT = new PassStmt(uxleft, nlxright); :}
      ;

expr_stmt ::= expr:e NEWLINE {: RESULT = new ExprStmt(exleft, exright, e); :}
          ;

return_stmt ::= RETURN:n expr:e NEWLINE:nl {: RESULT = new ReturnStmt(nxleft, nlxright, e); :}
             | RETURN:n NEWLINE:nl {: RESULT = new ReturnStmt(nxleft, nlxright, null); :}
             ;

pass_stmt ::= PASS:p NEWLINE:nl {: RESULT = new PassStmt(pxleft, nlxright); :}
           ;

if_stmt ::= IF:if expr:c COLON block:t opt_elif_else:e
           {: RESULT = new IfStmt(idxleft, getRight(e, t), c, t, e); :}
         ;
         

opt_elif_else ::= /* empty */ {: RESULT = empty(); :}
                | elif_list:l {: RESULT = l; :}
                | elif_list:l ELSE COLON block:b {: RESULT = combine(l, new ElifBranch(exleft, b)); :}
                | ELSE COLON block:b {: RESULT = single(new ElifBranch(exleft, b)); :}
                ;

elif_list ::= ELIF expr:c COLON block:b {: RESULT = single(new ElifBranch(c, b)); :}
           | elif_list:l ELIF expr:c COLON block:b {: RESULT = combine(l, new ElifBranch(c, b)); :}
           ;  /* PROBLEMA AQUI */
        

while_stmt ::= WHILE:w expr:c COLON block:b {: RESULT = new WhileStmt(wxleft, getRight(b), c, b); :}
            ;

for_stmt ::= FOR:f IDENTIFIER:id IN expr:iter COLON block:b
           {: RESULT = new ForStmt(fxleft, getRight(b), id, iter, b); :}
          ;

expr ::= binary_expr:e  {: RESULT = e; :}
     | unary_expr:e     {: RESULT = e; :}
     | literal_expr:e   {: RESULT = e; :}
     | primary_expr:e   {: RESULT = e; :}
     ;

binary_expr ::= expr:e1 PLUS:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 MINUS:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 MULT:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 INTDIV:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 MOD:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 EQEQ:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 NOTEQ:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 LT:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 LTE:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 GT:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 GTE:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 AND:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 OR:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | expr:e1 IS:op expr:e2
               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            ;

unary_expr ::= NOT:op expr:e {: RESULT = new UnaryExpr(opxleft, exright, op, e); :}
            ;

literal_expr ::= NUMBER:n {: RESULT = new IntegerLiteral(nxleft, nxright, n); :}
              | STRING_LITERAL:s {: RESULT = new StringLiteral(sxleft, sxright, s); :}
              | TRUE:t {: RESULT = new BooleanLiteral(txleft, txright, true); :}
              | FALSE:f {: RESULT = new BooleanLiteral(fxleft, fxright, false); :}
              | NONE:n {: RESULT = new NoneLiteral(nxleft, nxright); :}
              ;

primary_expr ::= IDENTIFIER:id {: RESULT = new Identifier(idxleft, idxright, id); :}
              | LPAREN expr:e RPAREN {: RESULT = e; :}
              | func_call:e {: RESULT = e; :}
              | attr_access:e {: RESULT = e; :}
              | index_access:e {: RESULT = e; :}
              ;

global_stmt ::= GLOBAL:g IDENTIFIER:id NEWLINE:nl {: RESULT = new PassStmt(gxleft, nlxright); :};
nonlocal_stmt ::= NONLOCAL:n IDENTIFIER:id NEWLINE:nl {: RESULT = new PassStmt(nxleft, nlxright); :};

func_call ::= primary_expr:e1 LPAREN opt_expr_list:args RPAREN:rp
           {: RESULT = new CallExpr(e1xleft, rpxright, e1, args); :}
           ;

attr_access ::= primary_expr:e1 DOT IDENTIFIER:id
             {: RESULT = new MemberExpr(e1xleft, idxright, e1, id); :}
             ;

index_access ::= primary_expr:e1 LBRACK expr:e2 RBRACK:rb
              {: RESULT = new IndexExpr(e1xleft, rbxright, e1, e2); :}
              ;

opt_expr_list ::= /* empty */ {: RESULT = empty(); :}
               | expr_list:l {: RESULT = l; :}
               ;

expr_list ::= expr:e {: RESULT = single(e); :}
          | expr_list:l COMMA expr:e {: RESULT = combine(l, e); :}
          ;

type ::= IDENTIFIER:id {: RESULT = new IdType(idxleft, id); :}
      | STRING_LITERAL:s {: RESULT = new StringType(sxleft, s); :}
      | LBRACK:lb type:t RBRACK {: RESULT = new ListType(lbxleft, t); :}
      ;
