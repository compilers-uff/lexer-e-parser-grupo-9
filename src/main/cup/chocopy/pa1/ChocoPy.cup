import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;

import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated
 * parser class. */
parser code {:

    /* The following fields and methods deal with error reporting
     * Avoid changing these unless you know what you are doing. */

    /** Node that accumulates error messages to be added to the Program
     *  node produced as a result. */
    public final Errors errors = new Errors(new ArrayList<>());

    /** Return the Program node that results from parsing the stream of
     *  tokens produced by lexical analysis.  In the case of syntax errors,
     *  the program may be empty, but will have error messages. */
    public Program parseProgram(boolean debug) {
        try {
            Symbol result = debug ? debug_parse() : parse();
            if (result == null || !(result.value instanceof Program)) {
                return new Program(new Location(0, 0), new Location(0, 0),
                                   new ArrayList<Declaration>(),
                                   new ArrayList<Stmt>(),
                                   errors);
            } else {
                return (Program) result.value;
            }
        } catch (RuntimeException excp) {
            throw excp;
        } catch (Exception excp) {
            String msg =
                String.format("Internal parser error detected: %s%n", excp);
            throw new AssertionError(msg);
        }
    }

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                String text = ((ChocoPyLexer) getScanner()).yytext();
                errors.syntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    "Parse error near token %s: %s", token, text);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        /* Do not die */
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE              
 *
 * The rules provided below parse expressions of the form <INT> + <INT> + ... 
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * location of the left end of the leftmost symbol in a rule and the
 * location of the right end of the rightmost symbol. The auto-generated
 * variables have names `<sym>xleft` and `<sym>xright`, where <sym> is the
 * name given to the symbol using the colon notation.
 *
 * When you have nonterminals that are lists of things, e.g. List<Stmt> or
 * List<Declaration>, it is helpful to get the leftmost and rightmost
 * source location from within this list; we have provided some utility
 * functions below to do just that.
 **************************************************************************/


/* The following code section is copied verbatim to the class that performs
 * production-rule actions. */
action code {:

    /** Return a mutable list initially containing the single value ITEM. */
    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** If ITEM is non-null, appends it to the end of LIST.  Then returns
     *  LIST. */
    <T> List<T> combine(List<T> list, T item) {
        if (item != null) {
            list.add(item);
        }
        return list;
    }
    <T> List<T> combine(List<T> list, List<T> item) {
        if (item != null) {
            Iterator<T> it = item.iterator();
            while(it.hasNext())
                list.add(it.next());
        }
        return list;
    }
    /** Return a mutable empty list. */
    <T> List<T> empty() {
        return new ArrayList<T>();
    }
    class FuncBody {
        public List<Declaration> fb;
        public List<Stmt> sl;
        public FuncBody(List<Declaration> fb, List<Stmt> sl){
            this.fb = fb;
            this.sl = sl;
        }
    }
    /** Return the leftmost non-whitespace location in NODES, or null if NODES
     *  is empty.  Assumes that the nodes of NODES are ordered in increasing
     *  order of location, from left to right. */
    ComplexSymbolFactory.Location getLeft(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node first = nodes.get(0);
        return new ComplexSymbolFactory.Location(first.getLocation()[0],
                                                 first.getLocation()[1]);
    }
    ComplexSymbolFactory.Location getRight(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node last = nodes.get(nodes.size()-1);
        return new ComplexSymbolFactory.Location(last.getLocation()[2],
                                                 last.getLocation()[3]);
    }
:}

/* Terminal symbols (tokens returned by the lexer).  The declaration
 *     terminal <identifier1>, <identifier2>, ...;
 * declares each <identifieri> as the denotation of a distinct type terminal
 * symbol for use in the grammar.  The declaration
 *     terminal <type> <identifier1>, ...;
 * does the same, and in addition indicates that the lexer supplies a
 * semantic value of type <type> for these symbols that may be referenced
 * in actions ( {: ... :} ).
 */

terminal String DEF, CLASS, IF, ELSE, ELIF, WHILE, FOR, IN, RETURN, PASS, NOT, AND, OR, IS, GLOBAL, NONLOCAL;
terminal Boolean BOOL;
terminal String EQ, EQEQ, NOTEQ, NONE, LT, LTE, GT, GTE;
terminal String PLUS, UMINUS, MINUS, MULT, INTDIV, DIV, MOD;
terminal String DOT, COLON, COMMA, LPAREN, RPAREN, LBRACK, RBRACK, ARROW, INDENT, DEDENT;
terminal NEWLINE;
terminal String UNRECOGNIZED;

terminal Integer NUMBER;
terminal String STRING;
terminal String IDENTIFIER;

/* Returned by the lexer for erroneous tokens.  Since it does not appear in
 * the grammar, it indicates a syntax error. */
  

/* Nonterminal symbols (defined in production rules below).
 * As for terminal symbols, 
 *     non terminal <type> <identifier1>, ..., <identifiern>; 
 * defines the listed nonterminal identifier symbols to have semantic values
 * of type <type>. */

non terminal Program           program;
non terminal List<Declaration> defs, program_head, opt_program_head, class_body, class_body_defs, fun_body_decs;
non terminal List<Stmt>        stmt_list, opt_stmt_list, block, else_body;
non terminal Stmt              stmt, simple_stmt;
non terminal Expr              expr, pexpr, cexpr;
non terminal VarDef            var_def;
non terminal ClassDef          class_def;
non terminal FuncDef           fun_def;
non terminal Literal           literal;
non terminal StringLiteral     bin_op, comp_op;
non terminal TypedVar          typed_var;
non terminal TypeAnnotation    type, ret_type;
non terminal Identifier        identifier;
non terminal List<TypedVar>    typed_vars;
non terminal GlobalDecl        global_decl;
non terminal NonLocalDecl      nonlocal_decl;
non terminal List<Expr>        opt_target, expr_list;
non terminal Expr              target;
non terminal MemberExpr        member_expr;
non terminal IndexExpr         index_expr;
non terminal FuncBody          fun_body;

/* Precedences (lowest to highest) for resolving what would otherwise be
 * ambiguities in the form of shift/reduce conflicts.. */

precedence left OR;
precedence left AND;
precedence right NOT;
precedence nonassoc EQEQ, NOTEQ, LT, LTE, GT, GTE, IS;
precedence left PLUS, MINUS;
precedence left MULT, DIV, UMINUS, INTDIV, MOD;
precedence left DOT, COMMA, LBRACK, RBRACK;
precedence right IF, ELSE;


/* The start symbol. */
start with program;


/*****  GRAMMAR RULES *****/

program ::= program_head:d opt_stmt_list:s
        {: 
        ComplexSymbolFactory.Location left = d.isEmpty() ? getLeft(s) : getLeft(d);
        if(left == null)
            left = new ComplexSymbolFactory.Location(1,1);
        RESULT = new Program(left, sxright, d, s, errors);
        :}
        ;

program_head ::= program_head:d var_def:vd              {: RESULT = combine(d, vd); :}
                | program_head:d class_def:cd           {: RESULT = combine(d, cd); :}
                | program_head:d fun_def:fd             {: RESULT = combine(d, fd); :}
                | program_head:d error:e                {: RESULT = d; :}
                |                                       {: RESULT = empty(); :}
                ;
                
opt_stmt_list ::=                    {: RESULT = empty(); :}
                | stmt_list:s        {: RESULT = s; :}
                ;


/* class_def */
class_def ::= CLASS:c identifier:id LPAREN identifier:parentId RPAREN COLON NEWLINE INDENT class_body:cb DEDENT   {: RESULT = new ClassDef(cxleft, getRight(cb), id, parentId, cb); :}; 


/* class_body */
class_body ::= PASS NEWLINE                             {: RESULT = empty(); :}
              | class_body_defs:defs                    {: RESULT = defs; :}
              ;
              
class_body_defs ::= class_body_defs:defs var_def:vd       {: RESULT = combine(defs, vd); :}
                  | class_body_defs:defs fun_def:fd       {: RESULT = combine(defs, fd); :}
                  | class_body_defs:defs error            {: RESULT = defs; :}
                  | var_def:vd                            {: RESULT = single(vd); :}
                  | fun_def:fd                            {: RESULT = single(fd); :}
                  ;


/* fun_def */
fun_def ::= DEF:def identifier:id LPAREN typed_vars:params RPAREN ret_type:rt COLON:col NEWLINE INDENT fun_body_decs:fbd stmt_list:sl DEDENT       
            {: TypeAnnotation _rt = rt;if((rt instanceof ClassType) && ((ClassType)rt).className == "<None>") _rt = new ClassType( colxright, colxright, "<None>");RESULT = new FuncDef(defxleft, getRight(sl), id, params, _rt, fbd, sl); :}
            ;

ret_type ::= ARROW type:t     {: RESULT= t; :}
          |                   {: RESULT= new ClassType(null, null,"<None>"); :}
          ;

typed_vars ::= typed_var:tv                                 {: RESULT= single(tv); :}
              | typed_vars:tvs COMMA typed_var:tv           {: RESULT= combine(tvs, tv); :}
              | typed_vars:tvs COMMA error                  {: RESULT= tvs; :}
              |                                             {: RESULT= empty(); :}
              ; 
                  
             
/* fun_body */   
fun_body ::=  fun_body_decs:fbd stmt_list:sl                {: RESULT = new FuncBody(fbd, sl);:}
            | fun_body_decs:fbd                             {: RESULT = new FuncBody(fbd, new ArrayList<Stmt>());:}
            ;

fun_body_decs ::= fun_body_decs:fbd  global_decl:gd         {: RESULT= combine(fbd, gd); :}
                | fun_body_decs:fbd  nonlocal_decl:nd       {: RESULT= combine(fbd, nd); :} 
                | fun_body_decs:fbd  var_def:vd             {: RESULT= combine(fbd, vd); :}
                | fun_body_decs:fbd  fun_def:fd             {: RESULT= combine(fbd, fd); :} 
                | fun_body_decs:fbd  error                  {: RESULT= fbd; :} 
                |                                           {: RESULT= empty(); :}
                ;
            

/* typed_var */
typed_var ::= identifier:id COLON type:t                 {: RESULT = new TypedVar(idxleft, txright, id, t); :};


/* type */
type ::= identifier:id                                   {: RESULT = new ClassType(idxleft, idxright, id.name); :}
      | STRING:str                                       {: RESULT = new ClassType(strxleft, strxright, str); :}
      | LBRACK:lbrack type:t RBRACK:rbrack                         {: RESULT = new ListType(lbrackxleft, rbrackxright, t); :}
      ;


/* global_decl */
global_decl ::= GLOBAL:g identifier:id NEWLINE             {: RESULT = new GlobalDecl(gxleft, idxright, id); :};


/* nonlocal_decl */
nonlocal_decl ::= NONLOCAL:n identifier:id NEWLINE        {: RESULT = new NonLocalDecl(nxleft, idxright, id); :};


/* var_def */
var_def ::= typed_var:t EQ literal:l NEWLINE          {: RESULT = new VarDef(txleft, lxright, t, l); :};


/* stmt */
stmt ::= simple_stmt:s NEWLINE                                            {: RESULT = s; :}
        | IF:i expr:cond COLON block:b else_body:elb                      {: RESULT = new IfStmt(ixleft, getRight(elb), cond, b, elb); :}
        | WHILE:wh expr:cond COLON block:b                                {: RESULT = new WhileStmt(whxleft, getRight(b), cond, b); :}
        | FOR:f identifier:id IN expr:e COLON block:b                     {: RESULT = new ForStmt(fxleft, getRight(b), id,  e, b); :}
        ;


else_body ::= ELSE:el COLON block:b                                       {: RESULT = b; :}
            |  ELIF:el expr:cond COLON block:b else_body:elb              {: RESULT = single(new IfStmt(elxleft, getRight(elb), cond, b, elb)); :}
            |                                                             {: RESULT = empty(); :}
            ;
    
    
/* simple_stmt */
simple_stmt ::= PASS:p                                        {: RESULT = null; :}
              | expr:e                                        {: RESULT = new ExprStmt(exleft, exright, e); :}
              | RETURN:r expr:e                               {: RESULT = new ReturnStmt(rxleft, exright, e); :}
              | RETURN:r                                        {: RESULT = new ReturnStmt(rxleft, rxright, null); :}
              | opt_target:ot expr:e                          {: RESULT = new AssignStmt(getLeft(ot), exright, ot, e); :}
            ;
            
            
opt_target ::= opt_target:ot target:t EQ                  {: RESULT = combine(ot, t); :}
              | target:t EQ                               {: RESULT = single(t); :}
              ;
        
        
/* block */      
block ::= NEWLINE INDENT stmt_list:sl DEDENT                 {: RESULT = sl; :};


/* literal */
literal ::= NONE:n                                        {: RESULT = new NoneLiteral(nxleft, nxright); :}
          | BOOL:b                                        {: RESULT = new BooleanLiteral(bxleft, bxright, b); :}
          | NUMBER:n                                      {: RESULT = new IntegerLiteral(nxleft, nxright, n); :}
          | STRING:s                                      {: RESULT = new StringLiteral(sxleft, sxright, s); :}
          ;
  
  
/* expr */ 
expr ::= cexpr:ce                                         {: RESULT = ce; :}
        | NOT:n expr:exp                                  {: RESULT = new UnaryExpr(nxleft, expxright, n, exp); :}
        | expr:e1 AND:a expr:e2                           {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, a, e2); :}
        | expr:e1 OR:o expr:e2                            {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, o, e2);  :}
        | expr:e1 IF expr:e2 ELSE expr:e3                 {: RESULT = new IfExpr(e1xleft, e3xright, e2, e1, e3); :}
       ;


/* cexpr */
cexpr ::= pexpr:pe                                {: RESULT = pe; :}
          | pexpr:p1 comp_op:co cexpr:p2          {: RESULT = new BinaryExpr(p1xleft, p2xright, p1, co.value, p2); :}
        ;


/* pexpr */
pexpr ::= identifier:id                                   {: RESULT = id; :}
        | literal:l                                       {: RESULT = l; :}
        | LBRACK:LBRACK expr_list:l RBRACK:RBRACK                     {: RESULT = new ListExpr(LBRACKxleft, RBRACKxright, l); :}
        | LPAREN:LPAREN expr:e RPAREN:RPAREN                      {: RESULT = e; :}
        | member_expr:m                                   {: RESULT = m; :}
        | index_expr:i                                    {: RESULT = i; :}
        | member_expr:m LPAREN expr_list:l RPAREN:RPAREN        {: RESULT = new MethodCallExpr(mxleft, RPARENxright, m, l); :}
        | identifier:id LPAREN expr_list:l RPAREN:RPAREN        {: RESULT = new CallExpr(idxleft, RPARENxright, id, l); :}
        | pexpr:p1 PLUS:bo pexpr:p2                       {: RESULT = new BinaryExpr(p1xleft, p2xright, p1, bo, p2); :}
        | pexpr:p1 MINUS:bo pexpr:p2                      {: RESULT = new BinaryExpr(p1xleft, p2xright, p1, bo, p2); :}
        | pexpr:p1 MULT:bo pexpr:p2                        {: RESULT = new BinaryExpr(p1xleft, p2xright, p1, bo, p2); :}
        | pexpr:p1 DIV:bo pexpr:p2                        {: RESULT = new BinaryExpr(p1xleft, p2xright, p1, bo, p2); :}
        | pexpr:p1 MOD:bo pexpr:p2                        {: RESULT = new BinaryExpr(p1xleft, p2xright, p1, bo, p2); :}
        | MINUS:m pexpr:p                                 {: RESULT = new UnaryExpr(mxleft, pxright, m, p); :} %prec UMINUS
        ;
        
expr_list ::= expr:e                                      {: RESULT = single(e); :}
            | expr_list:el COMMA expr:e                   {: RESULT = combine(el, e); :}
            |                                             {: RESULT = new ArrayList<Expr>(); :}
            ;

/* bin_op */ //We may still be able to use bin_op, so I left it here.
bin_op ::= PLUS:a                                           {: RESULT = new StringLiteral(axleft, axright, "+"); :}
          | MINUS:a                                         {: RESULT = new StringLiteral(axleft, axright, "-"); :}
          | MULT:a                                           {: RESULT = new StringLiteral(axleft, axright, "*"); :}
          | DIV:a                                           {: RESULT = new StringLiteral(axleft, axright, "//"); :}  
          | MOD:a                                           {: RESULT = new StringLiteral(axleft, axright, "%"); :} 
          ;


/* comp_op */ //this might also need some change in order not to break left associativity
comp_op ::= EQEQ:a                                          {: RESULT = new StringLiteral(axleft, axright, "=="); :} 
          | NOTEQ:a                                         {: RESULT = new StringLiteral(axleft, axright, "!="); :} 
          | LTE:a                                           {: RESULT = new StringLiteral(axleft, axright, "<="); :} 
          | GTE:a                                           {: RESULT = new StringLiteral(axleft, axright, ">="); :} 
          | LT:a                                            {: RESULT = new StringLiteral(axleft, axright, "<"); :} 
          | GT:a                                            {: RESULT = new StringLiteral(axleft, axright, ">"); :} 
          | IS:a                                            {: RESULT = new StringLiteral(axleft, axright, "is"); :}
          ;


/* member_expr */
member_expr ::= pexpr:p DOT identifier:id                   {: RESULT = new MemberExpr(pxleft, idxright, p, id); :}
              ;


/* index_expr */
index_expr ::= pexpr:p LBRACK expr:e RBRACK:rbrack          {: RESULT = new IndexExpr(pxleft, rbrackxright, p, e); :}
              ;
    
    
/* target */
target ::= identifier:id                                    {: RESULT = id; :}
          | member_expr:m                                   {: RESULT = m; :} 
          | index_expr:i                                    {: RESULT = i; :}
          ;
              
identifier ::= IDENTIFIER:idStr                             {: RESULT = new Identifier(idStrxleft, idStrxright, idStr); :};


stmt_list ::= stmt:s                                        {: RESULT = single(s); :}
            | stmt_list:l stmt:s                            {: RESULT = combine(l, s); :}
            | stmt_list:l error                             {: RESULT = l; :}
            ;
